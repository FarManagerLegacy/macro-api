Взаимодействие с системой
=========================

:::functions
`V=mf.clip(Cmd[,Value])`
:	Позволяет производить разнообразные манипуляции с Clipboard в зависимости от заданного действия `Action`:

	`0`
	:	Возвращает данные из Clipboard; параметр `Value` игнорируется;

	`1`
	:	Поместить строку `Value` в Clipboard;

	`2`
	:	Добавить строку `Value` к Clipboard;

	`3`
	:	Копировать Windows Clipboard во внутренний буфер обмена; параметр `Value` игнорируется;

	`4`
	:	Копировать внутренний буфер обмена в Windows Clipboard; параметр `Value` игнорируется;

	`5`
	:	Режимы работы с буфером обмена.

		По умолчанию в операциях запоминания/вставки данных Far Manager работает с буфером обмена Windows.

		Вызов `mf.clip(5)` позволяет в пределах одного макроса переключать внутренние механизмы Far Manager
		для работы с/без использования буфера обмена Windows.

		`Value` может быть одним из:

		`-1`
		:	Какой буфер обмена сейчас используется

		`0`
		:	Переключить работу с буфера обмена OS на внутренний буфер и наоборот (работает как триггер).

		`1`
		:	Включить буфер обмена OS

		`2`
		:	Включить внутренний буфер обмена

		Функция возвращает предыдущее значение: `1` - буфер обмена OS, `2` - внутренний буфер.

		Пример см. в разделе [Примеры].

	В случае ошибки возвращает `0`.

	Например, поместить в Clipboard список отмеченных файлов в формате CSV (имя и размер):

	~~~lua
	local APANEL = 0
	local FILENAME,ATTRIB,SIZE,SELECTED = 0,2,6,8
	local DIRECTORY = 0x00000010
	local function isFolder(panel,idx)
	  return band(DIRECTORY,Panel.Item(panel,idx,ATTRIB))==DIRECTORY
	end
	local PUT,ADD = 1,2
	Macro {
	  description="поместить в Clipboard список отмеченных файлов в формате CSV (имя и размер)";
	  area="Shell"; key="CtrlShiftIns";
	  action=function()
	    mf.clip(PUT,"Name;Size\r\n")
	    for i=1,APanel.ItemCount do
	      if not isFolder(APANEL,i) and Panel.Item(APANEL,i,SELECTED) then
	        mf.clip(ADD,Panel.Item(APANEL,i,FILENAME)..";"..Panel.Item(APANEL,i,SIZE).."\r\n")
	      end
	    end
	  end;
	}
	~~~

`S=mf.env(Name[,Mode[,Value]])`
:	Позволяет работать с переменной среды `Name`.
	Если `Mode` не указан или равен `0`, то функция возвращает значение переменной среды
	(`Value` в этом случае игнорируется). Если `Mode` указан и отличен от `0`,
	то функция устанавливает значение или удаляет переменную среды.

	Для варианта установки/удаления функция возвращает предыдущее значение
	(или пустую строку, если переменная была не определена).

	Примеры.

	:::examples
	Получить значение переменной среды `Foo`
	:	~~~lua
		mf.env("Foo")
		mf.env("Foo",0)
		mf.env("Foo",0,любое_значение)
		mf.env("Foo",nil,любое_значение)
		~~~

	Установить значение переменной среды `Foo` в "`bar`"
	:	`mf.env("Foo",1,"Bar")`

	Удалить переменную среды `Foo`
	:	~~~lua
		mf.env("Foo",1)
		mf.env("Foo",1,"")
		~~~

	Установить значение переменной среды `Foo` в "`0`"
	:	~~~lua
		mf.env("Foo",1,"0")
		mf.env("Foo",1,0)
		~~~

	Если выбран английский язык интерфейса Far Manager, то что-то делаем
	:	~~~lua
		if mf.env("FARLANG")=="English" then
		  -- что-то делаем
		end
		~~~
	:::

`V=mf.flock(Lkey,Action)`
:	Позволяет управлять состоянием Lock-клавиш (~NumLock~, ~CapsLock~ и ~ScrollLock~).

	Клавиша `Lkey`:

	`0`
	:	~NumLock~

	`1`
	:	~CapsLock~

	`2`
	:	~ScrollLock~

	Действие `Action`:

	`-1`
	:	получить состояние клавиши

	`0`
	:	погасить индикатор

	`1`
	:	включить индикатор

	`2`
	:	переключить индикатор в противоположное состояние

	Функция в младшем бите возвращает предыдущее значение режима выбранной клавиши (или текущее, если `Action=-1`).

	Старший бит будет установлен, если в момент вызова функции клавиша удерживается.

	Примечание:

	Особенности текущей реализации: чтобы изменить состояние режима
	в момент удержания клавиши может понадобиться повторный вызов функции.

	Поэтому, например, макрос, назначенный на ~Ctrl+CapsLock~ может быть таким:

	~~~lua
	local Caps,toggle = 1,2
	Macro {
	  description="переключение между окнами";
	  area="Shell Info QView Tree Editor Viewer"; key="CtrlCapsLock";
	  action=function()
	    Keys("CtrlShiftTab")
	    local mode = band(mf.flock(Caps,toggle),1)
	    mf.flock(Caps,1-mode)
	  end;
	}
	~~~

`N=Far.KbdLayout ([V])`
:	Управление раскладкой клавиатуры.

	Параметр `V`:

	`0`
	:	Вернуть текущее значение раскладки

	`1`
	:	Переключиться на следующую раскладку (по кругу)

	`-1`
	:	Переключиться на предыдущую раскладку (по кругу)

	Прочие значения
	:	Переключиться в конкретную раскладку (например, `0x0409` или `0x4090409` - английская,
		`0x0419` или `0x04190419` - русская)

		В случае указания несуществующей раскладки функция ошибку не выдаст и просто вернёт текущую раскладку.

	Функция возвращает предыдущее значение раскладки или `0` в случае ошибки
	(не удалось определить имя текущей раскладки для консоли или не удалось получить описатель консольного окна).

	Например (в командной строке):

	:::examples
	`lua:=mf.itoa(Far.KbdLayout(0x421),16)`
	:	при текущей русской раскладке просто вернёт `4190419`

	`lua:=mf.itoa(Far.KbdLayout(),16)`
	:	при текущей русской раскладке вернёт `4190419`

	`lua:=mf.itoa(Far.KbdLayout(0x409),16)`
	:	при текущей русской раскладке вернёт `4190419` и переключит рaскладку на английскую

	`lua:=mf.itoa(Far.KbdLayout(1),16)`
	:	при текущей русской раскладке вернёт `4190419` и переключит на следующую рaскладку (по кругу)
	:::

`N=Far.Window_Scroll(Lines[,Axis])`
:	Функция позволяет перемещать консольное окно по буферу.

	`Lines` - количество позиций для прокрутки:
	положительное число - вперёд (вниз/вправо), отрицательное - назад (вверх/влево).

	`Axis` - направление прокрутки (необязательный параметр):
	`0` - вертикаль (по умолчанию), `1` - горизонталь.

	Функция возвращает `false`, если перемотка не состоялась (например, `Lines` был равен `0`), иначе `true`.
:::


[Примеры]: examples.md
